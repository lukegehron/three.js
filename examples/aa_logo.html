<!DOCTYPE html>
<html lang="en">

<head>
	<title>LUKE GEHRON // PROJECTS</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block;}audio,canvas,video{display:inline-block;}audio:not([controls]){display:none;height:0;}[hidden]{display:none;}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}body{margin:0;}a:focus{outline:thin dotted;}a:active,a:hover{outline:0;}h1{font-size:2em;margin:0.67em 0;}abbr[title]{border-bottom:1px dotted;}b,strong{font-weight:bold;}dfn{font-style:italic;}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0;}mark{background:#ff0;color:#000;}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em;}pre{white-space:pre-wrap;}q{quotes:"\201C" "\201D" "\2018" "\2019";}small{font-size:80%;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}sup{top:-0.5em;}sub{bottom:-0.25em;}img{border:0;}svg:not(:root){overflow:hidden;}figure{margin:0;}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:0.35em 0.625em 0.75em;}legend{border:0;padding:0;}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0;}button,input{line-height:normal;}button,select{text-transform:none;}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer;}button[disabled],html input[disabled]{cursor:default;}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0;}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box;}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none;}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0;}textarea{overflow:auto;vertical-align:top;}table{border-collapse:collapse;border-spacing:0;}
*,
*::after,
*::before {
	box-sizing: border-box;
}

:root {
	font-size: 15px;
}

html {
	height: 100%;
}

html {
    overflow: scroll;
    overflow-x: hidden;
}
::-webkit-scrollbar {
    width: 0px;  /* Remove scrollbar space */
    background: transparent;  /* Optional: just make scrollbar invisible */
}
/* Optional: show position indicator in red */
::-webkit-scrollbar-thumb {
    background: #FF0000;
}

body {
	height: 100%;
	--color-text: #697c7e;
	--color-bg: #fff;
	--color-link: #697c7e;
	--color-link-hover: #fff;
	color: var(--color-text);
	background-color: var(--color-bg);
	font-family: Roboto, -apple-system, BlinkMacSystemFont, Segoe UI, Oxygen, Ubuntu, Cantarell,
    Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
	text-rendering: optimizeLegibility;
	min-height: 15000px;
}

canvas {
	position: fixed;
	top: 0;
	left: 0;
}

a {
	text-decoration: none;
	color: var(--color-link);
	outline: none;
}

a:hover,
a:focus {
	color: var(--color-link-hover);
	outline: none;
}

.frame {
	/* background: rgba(255, 255, 255, 1); */
	padding: 0rem 5vw;
	text-align: center;
	/* position: fixed; */
	position: sticky;
	margin: auto;
	
	z-index: 1000;
}



.frame__title {
	font-size: 0rem;
	margin: 0 0 1rem;
	top:0;
	font-weight: normal;
}

.frame__links {
	/* text-align: center; */
	/* float: right; */
	display: inline;
}

.frame__github,
.frame__links a:not(:last-child),
.frame__demos a:not(:last-child) {
	margin-right: 1rem;
}

.frame__demos {
	margin: 1rem 0;
}

.frame__demo--current,
.frame__demo--current:hover {
	text-decoration: underline;
	color: var(--color-link);
}

.content {
	display: flex;
	flex-direction: column;
	width: 98vw;
	height: 100vh;
	justify-content: center;
	position: relative;
	align-items: center;
}

.header {
	width: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: column;
	position: relative;
	z-index: 1;
	will-change: opacity;
	/* opacity: 0; */
}

.header__title {
	color: #444;
	font-size: 4rem;
	text-transform: uppercase;
	margin-bottom: 5vh;
	letter-spacing: 0.15rem;
	/* background: linear-gradient(40deg, #fdf680 0%,#d6716d 50%, #a0fafb 100%); */
	background-size: cover;
	/* -webkit-background-clip: text; */
	/* -webkit-text-fill-color: transparent; */
	/* background-clip: text; */
	/* text-fill-color: transparent; */
	font-weight: 600;
}

.header__text {
	max-width: 80%;
	text-align: center;
	font-size: 1.3rem;
	color: #222;
	/* color: #393c46; */
}

.heading {
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: column;
	position: fixed;
	z-index: 1;
	will-change: opacity;
	opacity: 0;
	top: 200;
	line-height: 1.2;
	font-size: 2.5rem;
	text-align: center;
	/* color: black; */
	color: rgba(255, 255, 255, 0.8);
	width: 95%;
	left: 50%;
	transform: translateX(-50%);
	padding: 0 40px;
}


@media screen and (min-width: 53em) {
	.message {
		display: none;
	}
	.frame {
		background: rgba(255, 255, 255, 1);
		position: fixed;
		text-align: left;
		/* z-index: 10000; */
		z-index: 1;
		top: 0;
		left: 0;
		display: grid;
		align-content: space-between;
		width: 100%;
		max-width: none;
		height: 100vh;
		padding: 2rem 2.25rem;
		pointer-events: none;
		grid-template-columns: 25% 50% 25%;
		grid-template-rows: auto auto auto;
		grid-template-areas: 'title title ... '
							'... ... ...'
							'github demos links';
	}
	.frame__title-wrap {
		grid-area: title;
		display: flex;
	}
	.frame__title {
		margin: 0;
		font-size: 1rem;
	}
	
	.frame__github {
		grid-area: github;
		justify-self: start;
		margin: 0;
	}
	.frame__demos {
		margin: 0;
		grid-area: demos;
		justify-self: center;
	}
	.frame__links {
		grid-area: links;
		padding: 0;
		justify-self: end;
	}
	.frame a {
		pointer-events: auto;
	}
	.header__title {
		font-size: 7vw;
		letter-spacing: 0.5vw;
	}
	.heading {
		/* color:#000; */
		color:rgba(255, 255, 255, 0.8);
		line-height: 1.2;
		font-size: 2.5vw;
		max-width: 60%;
	}
}


.box{
	position: absolute;
	top: 90%;
	left: 50%;
	transform: translate(-50%, -50%);
}

.box span{
	display: block;
	width: 10px;
	height: 10px;
	border-bottom: 2px solid grey;
	border-right: 2px solid grey;
	transform: rotate(45deg);
	margin: -10px;
	animation: animate 3s infinite;
	z-index: -1;
}
/* 
.box span:nth-child(2)
{
	animation-delay: -0.2s;
}

.box span:nth-child(3)
{
	animation-delay: -0.4s;
} */

@keyframes animate{
	
	0%{
		opacity: 0;
		transform: rotate(45deg) translate(-20px, -20px);
	}
	50%{
		opacity: 1;
	}
	100%{
		opacity: 0;
		transform: rotate(45deg) translate(20px, 20px);
	}
}

	</style>

<script>
	document.documentElement.className = 'js';
	var supportsCssVars = function() {
		var e,
			t = document.createElement('style');
		return (
			(t.innerHTML = 'root: { --tmp-var: bold; }'),
			document.head.appendChild(t),
			(e = !!(
				window.CSS &&
				window.CSS.supports &&
				window.CSS.supports('font-weight', 'var(--tmp-var)')
			)),
			t.parentNode.removeChild(t),
			e
		);
	};
	supportsCssVars() ||
		alert('Please view this demo in a modern browser that supports CSS Variables.');
</script>
</head>

<body>
	<main>
		

	<div id="frame" class="frame">
		<div class="frame__title-wrap">
			<h1 class="frame__title">LUKE GEHRON</h1>
		</div>
		<div class="box">
			<span></span>
			<!-- <span></span>
			<span></span> -->
		  </div>
		<a class="frame__github" href="https://github.com/vaneenige/scroll-transitions-webgl">GitHub</a>
		<div class="frame__links">
			<a href="https://tympanus.net/Development/SVGImageHover/">Portfolio</a>
			<a href="https://tympanus.net/codrops/?p=38923">Resume</a>
		</div>
	</div>

	


	<div class="content content--canvas">
		<div class="header">
			<h1 class="header__title">LUKE GEHRON</h1>
			<p class="header__text"> Developing <u>interactive web apps</u>, <u>AR/VR experiences</u>, and <u>computational tools</u> for the AEC industry</p>
		</div>
		<div class="heading">
			
		</div>
		<div class="heading" style="color:rgba(0, 0, 0, 1);">
			<p>Continue scrolling for the experimental 3D interactive portfolio experience<br><span style="font-size: 0.5em; top: -2vh"> or <u>click here</u> to view the static version</span></p>
		</div>
		<div class="heading">
			<p><b>Treeeple:</b> <i>an AR treehouse generator which creates custom designs from standard parts, and without power tools</i></p>
			
		</div>
		<div class="heading">
			<p><b>Kaliedescope:</b> <i>an Embodied Carbon tool for creating more sustainable buildings</i></p>
		</div>

		<div class="heading">
			<p><b>Solar:</b> <i>an interactive web tool for designing windows and shading systems based on the direct sunlight in a space</i></p>
		</div>

		<div class="heading">
			<p><b>SpaceAR:</b> <i>an AR app to collaboratively design buildings from room adjacencies</i></p>
		</div>

		<div class="heading">
			<p><b>Sound Space:</b> <i>an interactive VR tool to visualize room acoustics for architects</i></p>
		</div>

		<div class="heading">
			<p><b>ARCHIVED PROJECTS</b></p>
		</div>

		<div class="heading">That's it, thank you for scrolling! :)</div>
	</div>
</main>
	<!-- <div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Rhino 3DM loader
		</div> -->

	<!-- <div class="header" style="height: 400vh;">
		<h1 class="header__title">Phenomenon</h1>
		<p class="header__text">WebGL based transitions on scroll</p>
	</div> -->
	<!-- <div class="heading">
			A tiny wrapper around three.js built for high-performance WebGL experiences.
		</div>
		<div class="heading">
			GPU based for smooth transitions like scale, rotation and movement.
		</div> -->

	<script src="https://unpkg.com/uos@1.1.1/dist/uos.umd.js"></script>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { Rhino3dmLoader } from './jsm/loaders/3DMLoader.js';

		import { GUI } from './jsm/libs/dat.gui.module.js';

		import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
		import { RenderPass } from './jsm/postprocessing/RenderPass.js';
		import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
		import { OutlinePass } from './jsm/postprocessing/OutlinePass.js';
		import { FXAAShader } from './jsm/shaders/FXAAShader.js';

		// import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
		// import { RenderPass } from './jsm/postprocessing/RenderPass.js';
		// import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
		import { CopyShader } from './jsm/shaders/CopyShader.js';
		// import { FXAAShader } from './jsm/shaders/FXAAShader.js';

		import { Line2 } from './jsm/lines/Line2.js';
		import { LineMaterial } from './jsm/lines/LineMaterial.js';
		import { LineGeometry } from './jsm/lines/LineGeometry.js';
		import { GeometryUtils } from './jsm/utils/GeometryUtils.js';

		let currentScroll = 0;

		uos(0, 1.00, p => (currentScroll = p*4)) // vh/2

		const headings = document.querySelectorAll('.heading');
		const header = document.querySelector('.header');

		// uos(0, 1, p => render());

		uos(0, 0.05, p => (header.style.opacity = 1 - p));

		let instances = [0,1,2,3,4,5,6,7]

		const step = 1 / instances.length;
		for (let i = 0; i < instances.length; i += 1) {
		const transitionBegin = i * step;
		const transitionEnd = transitionBegin + step * 0.5;
		const textEnd = (i + 1) * step;
		// uos(transitionBegin, transitionEnd, p => (instances[i].uniforms.time.value = p));
		uos(transitionEnd, textEnd, p => {
			let np = p * 2.0 - 1.0;
			np = 1.0 - np * np;
			headings[i].style.opacity = i === instances.length - 1 ? p * 1.5 : np * 1.5;
		});
		}



		let container, controls;
		let camera, scene, renderer;
		// let gui;
		let selectedObjects = []
		let lineObjects = [];

		let goTime = false;

		let line, camera2;
		let line1;
		let matLine, matLineBasic, matLineDashed;

		let composer, effectFXAA, outlinePass;

		let mouseX = 0
		let mouseY = 0


		let windowHalfX = window.innerWidth / 2;
		let windowHalfY = window.innerHeight / 2;



		const params = {
			edgeStrength: 3.4, //8.9
			edgeGlow: 0.0,
			edgeThickness: 1, //2.1
			pulsePeriod: 0,
			rotate: false,
			usePatternTexture: false
		};
		// Init gui

		const gui = new GUI({ width: 300 });
		gui.close()

		gui.add(params, 'edgeStrength', 0.01, 10).onChange(function (value) {

			outlinePass.edgeStrength = Number(value);

		});

		gui.add(params, 'edgeGlow', 0.0, 1).onChange(function (value) {

			outlinePass.edgeGlow = Number(value);

		});

		gui.add(params, 'edgeThickness', 1, 4).onChange(function (value) {

			outlinePass.edgeThickness = Number(value);

		});

		gui.add(params, 'pulsePeriod', 0.0, 5).onChange(function (value) {

			outlinePass.pulsePeriod = Number(value);

		});

		gui.add(params, 'rotate');

		gui.add(params, 'usePatternTexture').onChange(function (value) {

			// outlinePass.usePatternTexture = value;

		});

		function Configuration() {

			this.visibleEdgeColor = '#666666'; //'#000000'
			this.hiddenEdgeColor = '#190a05';

		}

		const conf = new Configuration();

		gui.addColor(conf, 'visibleEdgeColor').onChange(function (value) {

			outlinePass.visibleEdgeColor.set(value);

		});

		gui.addColor(conf, 'hiddenEdgeColor').onChange(function (value) {

			outlinePass.hiddenEdgeColor.set(value);

		});

		let rhinoObject;

		let currentState = 0;

		// let matLine;

		let startOpactityChange = false;
let mFrame = document.getElementById("frame")
		let currentOpactity = 1.0;

		init();
		animate();

		function init() {

			THREE.Object3D.DefaultUp = new THREE.Vector3(0, 0, 1);
			container = document.createElement('div');
			container.style.height = "150vh";
			container.style.top = "0px"
			container.style.position = "fixed"
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(12, window.innerWidth / window.innerHeight, 1, 3000);
			camera.position.set(590, -590, 590);
			// camera.lookAt(100,140,0)

			scene = new THREE.Scene();

			scene.background = new THREE.Color(0xffffff);
			// scene.setClearColor( 0xffffff, 0);

			const ambient = new THREE.AmbientLight(0xffffff, 1.50); //5
			scene.add(ambient);

			const directionalLight = new THREE.DirectionalLight(0xffffff);
			directionalLight.position.set(0, 0, 2);
			directionalLight.castShadow = true;
			directionalLight.intensity = 2;
			scene.add(directionalLight);



			const width = window.innerWidth;
			const height = window.innerHeight;

			renderer = new THREE.WebGLRenderer({ antialias: true }); //, alpha: true
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(width, height);
			container.appendChild(renderer.domElement);
			// renderer.shadowMap.enabled = true;

			// controls = new OrbitControls( camera, container );

			composer = new EffectComposer(renderer);

			const renderPass = new RenderPass(scene, camera);
			composer.addPass(renderPass);

			outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
			outlinePass.overlayMaterial.blending = THREE.SubtractiveBlending
			// outlinePass.overlayMaterial.blending = THREE.CustomBlending
			outlinePass.edgeStrength = 3.4 //8.9
			outlinePass.edgeThickness = 1.0 //2.2
			composer.addPass(outlinePass);

			const textureLoader = new THREE.TextureLoader();
			textureLoader.load('textures/tri_pattern.jpg', function (texture) {

				outlinePass.patternTexture = texture;
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;

			});

			// 				var fxaaPass = new THREE.ShaderPass( THREE.FXAAShader );

			// var pixelRatio = renderer.getPixelRatio();
			// var uniforms = fxaaPass.material.uniforms;

			// uniforms[ 'resolution' ].value.x = 1 / ( window.innerWidth * pixelRatio );
			// uniforms[ 'resolution' ].value.y = 1 / ( window.innerHeight * pixelRatio );

			// effectFXAA = new ShaderPass( FXAAShader );
			// effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
			// composer.addPass( effectFXAA );

			let fxaaPass = new ShaderPass(FXAAShader);
			// const renderPass = new RenderPass( scene, camera );

			const pixelRatio = renderer.getPixelRatio();

			fxaaPass.material.uniforms['resolution'].value.x = 1 / (container.offsetWidth * pixelRatio);
			fxaaPass.material.uniforms['resolution'].value.y = 1 / (container.offsetHeight * pixelRatio);

			let composer1 = new EffectComposer(renderer);
			composer1.addPass(renderPass);
			composer1.addPass(fxaaPass);

			// outlinePass.selectedObjects = selectedObjects;

			const loader = new Rhino3dmLoader();
			loader.setLibraryPath('jsm/libs/rhino3dm/');

			loader.load('models/3dm/Export24.3dm', function (object) { //13

				// outlinePass.selectedObjects = object
				// console.log(object.children[0])
				for (let i = 0; i < object.children.length; i++) {
					if (object.children[i].type == "Object3D") {
						// console.log(object.children[i])
						// console.log(object.children[i].children.length)
						for (let j = 0; j < object.children[i].children.length; j++) {
							// console.log(j)
							// scene.add(object.children[i].children[j])
							// object.children[i].children[j].material.wireframe = true
							selectedObjects.push(object.children[i].children[j])
						}
					} else if (object.children[i].type == "Line") {
						// console.log(object.children[i].position)
						// matLine = new LineMaterial( {

						// 	color: 0xff0000,
						// 	linewidth: 5, // in pixels
						// 	vertexColors: true,
						// 	//resolution:  // to be set by renderer, eventually
						// 	dashed: false

						// 	} );

						object.children[i].material.color = new THREE.Color(0xffffff)
						object.children[i].position.x = -0.03
						object.children[i].position.y = -0.03
						// object.children[i].position.z = 0.03

						lineObjects.push(object.children[i])
						// object.children[i].material.vertexColors = true

					}

					// object.children[i].material.color = '0xff0000'


				}

				// console.log(selectedObjects.length)


				rhinoObject = object

				outlinePass.selectedObjects = selectedObjects;

				scene.add(object);
				// scene.add(selectedObjects)
				initGUI(object.userData.layers);

				goTime = true;

			});

			// scene.add(selectedObjects)

			// console.log(selectedObjects)

			var geometry = new THREE.BoxGeometry(1, 1, 1);
			var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
			var cube = new THREE.Mesh(geometry, material);
			scene.add(cube);
			cube.position.x = 0;
			cube.position.y = 0;
			cube.position.z = 0;
			// cube.position.z = ((currentScroll * 30) - 15);
			// camera.up.set( 0, 1,0 );
			// camera.lookAt((nowLookAtx, nowLookAty, nowLookAtz));
			// console.log(cube.position.y);
			camera.lookAt((cube.position));
			// console.log(cube.position.z)
			scene.remove(cube);


			window.addEventListener('resize', resize, false);

			document.addEventListener('mousemove', onDocumentMouseMove, false);

		}

		// function resize() {

		// 	const width = window.innerWidth;
		// 	const height = window.innerHeight;

		// 	camera.aspect = width / height;
		// 	camera.updateProjectionMatrix();

		// 	renderer.setSize( width, height );

		// }


		let xPos = [-20, 28, -32, 31, 13, -8, -38, -10, 14, -37, -8, 22, -2, 0, 38, -26, 15, -36, -29, 18, 33, 11, -39, 5, 37, -6, 11, -7, -18, -39, -33, -25, 38, 38, -12, 19, 25, -13, -35, 0, 32, -34, -37, -17, 36, -4, 5, -22, -11, 18, -34, -2, -3, 32, 27, 18, 6, 1, -38, -25, -19, 15, 24, 12, 37, -21, -39, 22, 18, 7, -18, -1, -26, -21, -10, 28, 35, -18, 28, 36, 19, 14, -20, -9, 21, 5, 27, 22, 9, -38, 4, -25, 21, 3, 26, -5, -27, -6, -1, 10, -19, 19, -32, -15, -14, 24, 10, 32, 3, -25, -31, -19, 22, -16, -40, -12, 7, 34, 14, 34, 0, -12, -15, -21, 10, -33, 36, 28, -38, -36, -15, -25, 32, 36, -39, -3, -25, -18, 20, -28, 3, -28, 18, -3, 24, -24, 34, -38, 4, -39, 35, -9, -39, -27, -39, -19, -22, 33, 29, 38, 3, -23, -37, -40, 34, 0, -4, 18, -15, 11, -26, -38, 0, -14, -6, -9, -27, 4]
		let yPos = [-33, 16, 28, -34, 27, 9, -8, 4, -29, -27, -32, 2, 16, -16, -13, 3, -18, 30, 31, -3, -33, 3, -38, 26, 22, -39, -32, -10, -9, -40, -15, 5, -17, 2, 30, 20, -16, 30, 13, -17, 7, -8, 5, -25, 28, -39, -38, -40, 18, -35, -31, 24, 2, -36, 4, 31, 5, -24, 7, 22, -10, 9, 29, -10, 28, -29, 15, -18, -11, -38, -14, 31, -29, 11, -25, 15, 30, 26, -6, -12, 17, 11, 21, 6, -40, 29, -24, -6, 24, 26, 13, -14, -31, 16, 21, -34, -25, -7, 18, -24, -39, -40, -20, 30, -22, 31, -4, 3, -8, 17, -39, 9, -25, 10, -19, -40, -9, -39, 31, -27, -17, -19, -4, -25, -40, 11, -9, -41, 28, -41, 17, -21, 29, 6, -28, -8, -7, 9, 11, 15, 6, -8, -9, -24, -13, 27, -25, 24, 5, -40, 14, -1, -24, -18, -4, -39, -3, -28, -15, -20, -13, -39, -4, -18, -19, 2, 15, -6, -3, 15, 3, -17, -39, -36, -24, 11, -38, -30]
		let zPos = [1, -13, 2, 17, 30, -19, 20, 32, -22, -25, 31, 13, 8, -5, -18, -6, 26, -22, 26, -12, -7, 29, -8, -17, 14, -19, 8, 17, -25, 28, 1, 12, 26, 0, -20, 15, 11, 12, -19, -22, 27, -22, 31, 18, 31, 13, -6, -25, -5, 31, 15, 28, -3, -24, -21, -2, -24, 21, 5, -11, 2, 3, -17, 14, -25, -15, 18, -4, -24, 23, 30, -4, 30, -24, -26, 2, -5, 1, 25, -4, -25, -13, 21, 14, -12, 18, 23, 1, 5, -9, 20, -9, -2, -4, 27, 1, -4, -14, -25, -7, 19, 20, 23, 31, 6, 8, -1, -11, 31, 4, 2, 25, -15, 3, -9, -8, -12, 28, -24, 6, 9, -10, -8, -26, -17, -5, 11, 7, 13, -20, 12, 11, 21, 16, 27, 2, 12, -14, 31, 28, -11, 28, 31, -14, -14, -22, -17, 25, 7, 17, -22, -23, 3, -21, -10, 30, 22, 30, -23, -25, 21, -7, 9, -19, 14, 30, 31, 22, 14, 28, -17, 12, 31, 8, 14, 23, 12, -26]




		function animate() {

			

		setTimeout(function(){ 
			startOpactityChange = true
		}, 2000);

		if(startOpactityChange){
			if(currentOpactity > 0){
				currentOpactity -= 0.05
				mFrame.style.backgroundColor = "rgba(255,255,255," + currentOpactity + ")" 
			}
		}

			var geometry = new THREE.BoxGeometry(1, 1, 1);
			var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
			var cube = new THREE.Mesh(geometry, material);
			scene.add(cube);
			cube.position.x = 0;
			cube.position.y = 0;
			cube.position.z = 0;
	
			camera.lookAt((cube.position));

			scene.remove(cube);

			// var geometry = new THREE.BoxGeometry(1, 1, 1);
			// var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
			// var cube = new THREE.Mesh(geometry, material);
			// scene.add(cube);
			// cube.position.x = 0;
			// cube.position.y = 0;

			// camera.lookAt((cube.position));

			// scene.remove(cube);


			// console.log(currentScroll)



			// camera.position.x = ((currentScroll * 300) - 150) + 590
			// camera.position.y = ((currentScroll * 300) - 150) - 590
			// camera.position.z = 590
			// camera.lookAt(0,0,(currentScroll * 300) - 150)



			// console.log(camera.position.z)

			// 590, -590, 250

			// camera.position.x += ( -mouseX - camera.position.x ) * .01;
			// camera.position.z += (  mouseY - camera.position.z ) * .01;

			// if(goTime){


			// camera.position.x += (590 + (-mouseX * 0.5) - camera.position.x) * .1 * currentScroll;
			// camera.position.y += (-590 + (-mouseX * 0.5) - camera.position.y) * .1 * currentScroll;
			// camera.position.z += (590 + (mouseY * 0.5) - camera.position.z) * .1 * currentScroll;

			// camera.position.x = (((-mouseX * 0.5)) * .5 * currentScroll)+590;
			// camera.position.y = (((-mouseX * 0.5)) * .5 * currentScroll)-590;
			// camera.position.z = (((-mouseY * 0.5)) * .5 * currentScroll)+590;

			// console.log((((-mouseX * 0.5)) * .5 * currentScroll)+590)

			// console.log(currentScroll)

			function map_range(value, low1, high1, low2, high2) {
				return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
			}

			if(currentScroll < 0.75)
			{scene.background = new THREE.Color(0xffffff)}
			else if(currentScroll < 1){
				let myRGB = map_range(currentScroll, 1, 0.75, 0.125, 1)
				scene.background = new THREE.Color(myRGB, myRGB, myRGB)
			}else{

				scene.background = new THREE.Color(0x222222)
			}

			if (selectedObjects.length > 177) {
				// console.log(selectedObjects.length)
				// if(selectedObjects[0].scale.x > 0){
				// console.log(selectedObjects[0].scale.x)
				let currentScroll1 = currentScroll - 0.1
				if(currentScroll1 < 0){
					currentScroll1 = 0
				}
				for (let i = 0; i < selectedObjects.length / 4; i++) {

					for (let j = 0; j < 4; j++) {

						if(currentScroll1 <= 1){
						selectedObjects[(i * 4) + j].scale.x = 1 - currentScroll1
						selectedObjects[(i * 4) + j].scale.y = 1 - currentScroll1
						selectedObjects[(i * 4) + j].scale.z = 1 - currentScroll1

						// 100

						selectedObjects[(i * 4) + j].rotation.x = zPos[i] * currentScroll1 * .1
						selectedObjects[(i * 4) + j].position.x = xPos[i] * currentScroll1 * 3.5

						selectedObjects[(i * 4) + j].rotation.y = xPos[i] * currentScroll1 * .1
						selectedObjects[(i * 4) + j].position.y = yPos[i] * currentScroll1 * 3.5

						selectedObjects[(i * 4) + j].rotation.z = yPos[i] * currentScroll1 * .1
						selectedObjects[(i * 4) + j].position.z = zPos[i] * currentScroll1 * 3.5
						}else{
							selectedObjects[(i * 4) + j].scale.x = 0
							selectedObjects[(i * 4) + j].scale.y = 0
							selectedObjects[(i * 4) + j].scale.z = 0
						}

					}
				}
				// }
			}





			// camera.p

			// camera.position.set(590 + (-mouseX*0.05), -590  + (-mouseX*0.05), 250 + (mouseY*0.05))
			// }

			// camera.postion.z = 250 + (mouseY*0.05)
			// console.log(camera.position.x)

			// console.log(camera.position.x, mouseX + " || " + camera.position.z, mouseY,)

			// camera.lookAt( scene.position );


			// controls.update();

			// if ( !params.rotate ) {


			// 	composer.render(scene, camera);
			// }else{

				let currentScroll1 = currentScroll - 0.1
				if(currentScroll1 < 0){
					currentScroll1 = 0
				}

			if (lineObjects.length > 100) {
				if (currentScroll1 > 0) {
					for (let i = 0; i < lineObjects.length; i++) {
						// if (rhinoObject.children.type == "Line") {
							// console.log("hello")
							// lineObjects[i].material.color = new THREE.Color(0xffffff)
							lineObjects[i].position.x = 10000
						// }
					}
				} else{
					for (let i = 0; i < lineObjects.length; i++) {
						// if (rhinoObject.children.type == "Line") {
							// console.log("hello")
							lineObjects[i].position.x = 0
						// }
					}

				}
				currentState++
			}
			renderer.render(scene, camera);
			// }



			// renderer.render( scene, camera );

			requestAnimationFrame(animate);

		}

		function initGUI(layers) {

			// gui = new GUI( { width: 300 } );
			const layersControl = gui.addFolder('layers');
			layersControl.open();

			for (let i = 0; i < layers.length; i++) {

				const layer = layers[i];
				layersControl.add(layer, 'visible').name(layer.name).onChange(function (val) {

					const name = this.object.name;

					scene.traverse(function (child) {

						if (child.userData.hasOwnProperty('attributes')) {

							if ('layerIndex' in child.userData.attributes) {

								const layerName = layers[child.userData.attributes.layerIndex].name;

								if (layerName === name) {

									child.visible = val;
									layer.visible = val;

								}

							}

						}

					});

				});

			}

		}

		function onDocumentMouseMove(event) {

			mouseX = (event.clientX - windowHalfX) / 2;
			mouseY = (event.clientY - windowHalfY) / 2;

			// console.log(mouseX, mouseY)

		}

		//

		// function animate() {

		// requestAnimationFrame( animate );
		// render();

		// }

		// function render() {

		// camera.position.x += ( mouseX - camera.position.x ) * .05;
		// camera.position.y += ( - mouseY - camera.position.y ) * .05;

		// camera.lookAt( scene.position );

		// renderer.render( scene, camera );

		// }

		// 			const headings = document.querySelectorAll('.heading');
		// const header = document.querySelector('.header');

		// uos(0, 1, p => render());


		// const step = 1 / instances.length;
		// for (let i = 0; i < instances.length; i += 1) {
		//   const transitionBegin = i * step;
		//   const transitionEnd = transitionBegin + step * 0.5;
		//   const textEnd = (i + 1) * step;
		//   uos(transitionBegin, transitionEnd, p => (instances[i].uniforms.time.value = p));
		//   uos(transitionEnd, textEnd, p => {
		//     let np = p * 2.0 - 1.0;
		//     np = 1.0 - np * np;
		//     headings[i].style.opacity = i === instances.length - 1 ? p * 1.5 : np * 1.5;
		//   });
		// }

		// let instances = [0,1,2]

		function resize() {

			const width = window.innerWidth;
			const height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
			//   camera.aspect = window.innerWidth / window.innerHeight;
			//   camera.updateProjectionMatrix();
			//   renderer.setSize(window.innerWidth, window.innerHeight);
			//   const divs = document.querySelectorAll('.heading');
			//   for (let i = 0; i < divs.length; i += 1) {
			//     divs[i].style.height = `${window.innerHeight}px`;
			//   }
			render();
		}

		function render() {

			//   renderer.render(scene, camera);
			// composer.render(scene, camera);

		}

// requestAnimationFrame(() => {
//   window.scrollTo(0, 0);
//   resize();
//   header.style.opacity = 1;
// });
	</script>

</body>

</html>