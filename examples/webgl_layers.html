<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - layers</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #f0f0f0;
			color: #444;
		}

		a {
			color: #08f;
		}
	</style>
</head>

<body>

	<div id="info">
		<!-- <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl layers -->
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';

			import { OBJLoader } from './jsm/loaders/OBJLoader.js';
			import { MTLLoader } from './jsm/loaders/MTLLoader.js';

			import { MapControls } from './jsm/controls/OrbitControls.js';

			import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
			import { SSAOPass } from './jsm/postprocessing/SSAOPass.js';

			import { Sky } from './jsm/objects/Sky.js';

			import { LightProbeGenerator } from './jsm/lights/LightProbeGenerator.js';
			import { FBXLoader } from './jsm/loaders/FBXLoader.js';

			var hasntBeenUpdated = true;

			var b = []; //box
			var spline;
			var boxPos;
			var boxyPosIndex = 0;

			var xPaths = [];
			var yPaths = [];
			var zPaths = [];


			var xArray = [];
			var yArray = [];
			var zArray = [];

			var peopleOn = false;


			var container, stats, controls;
			var camera, scene, renderer;
			var sky, sunSphere;

			var composer;

			var lightProbe, directionalLight;

			var effectController = {
				turbidity: 1,
				rayleigh: 4,
				mieCoefficient: 0.033,
				mieDirectionalG: 1,
				luminance: 0.9,
				inclination: 0.366, // elevation / inclination
				azimuth: 0.27, // Facing front,
				sun: ! true
			};
var localPlane;
var counter1 = 0;


			var API = {
				lightProbeIntensity: 1.0,
				directionalLightIntensity: 0.12,
				envMapIntensity: 0.8
			};

			var radius = 100, theta = 0;


			var params = {
				animate: true,
				planeY: {
					constant: 99,
					negated: false,
					displayHelper: false
				},
			};

			// var object1, object2;

			init();
			animate();

			function initSky() {

				// Add Sky
				sky = new Sky();
				sky.scale.setScalar( 450000 );
				scene.add( sky );

				// Add Sun Helper
				sunSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 20000, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				sunSphere.position.y = - 700000;
				sunSphere.visible = false;
				scene.add( sunSphere );

			}

			function init() {
				renderer = new THREE.WebGLRenderer({antialias: true});

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 5000 );

				controls = new MapControls(camera, renderer.domElement);
				controls.mouseButtons = {
				// LEFT: THREE.MOUSE.DOLLY,
				// MIDDLE: THREE.MOUSE.PAN,
				// RIGHT: THREE.MOUSE.ROTATE

				LEFT: THREE.MOUSE.PAN,
				MIDDLE: THREE.MOUSE.PAN,
				RIGHT: THREE.MOUSE.ROTATE

				// LEFT: THREE.MOUSE.ROTATE,
				// MIDDLE: THREE.MOUSE.DOLLY,
				// RIGHT: THREE.MOUSE.PAN
				}

				// camera.position.x = -1660;
				// camera.position.y = 1080;
				// camera.position.z = 1520;

				// camera.position.x = 157;
				// camera.position.y = -46.5;
				// camera.position.z = 280;
				camera.position.x = -1660;
				camera.position.y = 1080;
				camera.position.z = 1520;


				camera.layers.enable( 0 ); // enabled by default
				camera.layers.enable( 1 );
				camera.layers.enable( 2 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );
				// scene.background = new THREE.Color( 0xefd1b5 );
				// scene.fog = new THREE.FogExp2( 0xffffff, 0.001 );
				// scene.fog = new THREE.Fog( 0xCCCCCC, 50, 100 );

				// scene.add( new THREE.AmbientLight( 0x444444 ) );

							var	spotLight = new THREE.SpotLight( 0x888888 );
								spotLight.name = 'Spot Light';
								spotLight.angle = Math.PI / 5;
								spotLight.penumbra = 0.3;
								spotLight.position.set( 80, 200, 50 );
								spotLight.castShadow = true;
								spotLight.shadow.camera.near = 80;
								spotLight.shadow.camera.far = 2000;
								spotLight.shadow.mapSize.width = 1024;
								spotLight.shadow.mapSize.height = 1024;
								spotLight.shadow.bias = -0.002;
								spotLight.shadow.radius = 12;
								// scene.add( spotLight );
				// var light = new THREE.PointLight( 0xffffff, 0.1 );
				// light.layers.enable( 0 );
				// light.layers.enable( 1 );
				// light.layers.enable( 2 );

				var dirLight = new THREE.DirectionalLight( 0xFFFFFF, 0.1 );
				dirLight.name = 'Dir. Light';
				dirLight.position.set( 500, 1200, -750 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 5000;
				dirLight.shadow.camera.right = 1370;
				dirLight.shadow.camera.left = - 1370;
				dirLight.shadow.camera.top	= 1370;
				dirLight.shadow.camera.bottom = - 1370;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;
				dirLight.shadow.radius = 12;
				dirLight.shadow.bias = -0.0005;
				scene.add( dirLight );

				var dirGroup = new THREE.Group();
				dirGroup.add( dirLight );
				scene.add( dirGroup );

				scene.add( camera );


				// camera.add( light );
				scene.add( new THREE.AmbientLight( 0xffffff, 0.7 ) );
				var dirLight = new THREE.DirectionalLight( 0xffffff, 0.2 );
				dirLight.position.set( -50, 100, -75 );
				// dirLight.castShadow = true;

				scene.add( dirLight );

				initSky();







				// scene.add( new THREE.HemisphereLight( 0xffffff, 0.3) );



				// var colors = [ 0xff0000, 0x00ff00, 0x0000ff ];
				// var geometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
				var layer;

				// var material = new THREE.MeshPhongMaterial( {
				// color: 0x9999aa,
				// shininess: 0.6} );

				var genCubeUrls = function ( prefix, postfix ) {

					return [
						prefix + 'px' + postfix, prefix + 'nx' + postfix,
						prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix
					];

				};

				// var urls = genCubeUrls( 'textures/cube/MilkyWay/dark-s_', '.jpg' );
				var urls = genCubeUrls( 'textures/cube/skyboxsun25deg/', '.jpg' );

				new THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {

					cubeTexture.encoding = THREE.sRGBEncoding;

					// scene.background = cubeTexture;

					lightProbe.copy( LightProbeGenerator.fromCubeTexture( cubeTexture ) );

					// var geometry = new THREE.SphereBufferGeometry( 5, 64, 32 );
					//var geometry = new TorusKnotBufferGeometry( 4, 1.5, 256, 32, 2, 3 );

					scene.envionment = cubeTexture;

					var randomPoints = [];
					for ( var i = 0; i < 100; i ++ ) {
					    randomPoints.push(
					        new THREE.Vector3(Math.random() * 200 - 100, Math.random() * 200 - 100, Math.random() * 200 - 100)
					    );
					}
					spline = new THREE.SplineCurve3(randomPoints);

					boxPos = spline.getPoints(10000);








					localPlane = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );


					render();

					var loader = new FBXLoader();
					loader.load( 'models/fbx/lines2.fbx', function ( object ) {

						scene.add( object );

					} );



					var loader = new FBXLoader();
					loader.load( 'models/fbx/path2.fbx', function ( object ) {
						// console.log(object);
						// console.log(object.children[1].geometry.attributes.position.array[0]);
						for(let j = 0; j < object.children.length; j++){
							xArray = [];
							yArray = [];
							zArray = [];
							for (let i = 0; i < object.children[j].geometry.attributes.position.array.length; i++ ){
									if(i % 3 == 0){
										xArray.push(object.children[j].geometry.attributes.position.array[i]);
									}else if(i % 3 == 1){
										yArray.push(object.children[j].geometry.attributes.position.array[i]);
									}else{
										zArray.push(object.children[j].geometry.attributes.position.array[i]);
									}

							}
							xPaths.push(xArray);
							yPaths.push(yArray);
							zPaths.push(zArray);
						}

						// console.log(xArray[0]);


						// scene.add( object );

					} );

					var material9 = new THREE.MeshStandardMaterial( {
						color: 0xcfcdcc,
						metalness: 0.3,
						roughness: 0.7,
						envMap: cubeTexture,
						envMapIntensity: API.envMapIntensity,
						side: THREE.DoubleSide,

						// ***** Clipping setup (material): *****
						// clippingPlanes: [ localPlane ],
						// clipShadows: true
					} );


				var loader = new OBJLoader();
			  loader.load( 'models/obj/Site9-Terrain.obj', function ( obj )

			 {
				 obj.traverse( function ( child ) {

					 if ( child.isMesh ) child.material = material9;

				 } );
			    var layer = 1
			    var object = obj.children[ 0 ].clone();
					object.layers.set( layer );
					object.rotation.x = -3.1415926787/2;
					object.castShadow = true;
					object.receiveShadow = true;
			    scene.add( object );

			    });

				var	material = new THREE.MeshStandardMaterial( {
						color: 0xcccccf,
						metalness: 0.3,
						roughness: 0.7,
						envMap: cubeTexture,
						envMapIntensity: API.envMapIntensity,
						// side: THREE.DoubleSide,

						// ***** Clipping setup (material): *****

					} );
					var loader9 = new OBJLoader();

					loader9.load( 'models/obj/Site9-Buildings.obj', function ( obj )

				 {
					 obj.traverse( function ( child ) {

						 if ( child.isMesh ) child.material = material;

					 } );
				    var layer = 1
				    var object = obj.children[ 0 ].clone();
						object.layers.set( layer );
						object.rotation.x = -3.1415926787/2;
						object.castShadow = true;
						object.receiveShadow = true;
				    scene.add( object );

				    });

					let material1 = new THREE.MeshPhysicalMaterial({
						color: 0xffffff,
						clearcoat: 1,
						reflectivity: 1,
						metalness:1,
						roughness: 0,
						transparency: 0.7,
						transparent:true,
						envMap: cubeTexture,
						envMapIntensity: API.envMapIntensity,
						clippingPlanes: [ localPlane ],
						clipShadows: true
					})

					var loader = new OBJLoader();
				  loader.load( 'models/obj/Site9-Glass.obj', function ( obj )

				 {
					 obj.traverse( function ( child ) {

						 if ( child.isMesh ) child.material = material1;

					 } );
				    var layer = 2
				    var object = obj.children[ 0 ].clone();
						object.layers.set( layer );
						object.rotation.x = -3.1415926787/2;
						object.castShadow = true;
						object.receiveShadow = true;
				    scene.add( object );

				    });

				new MTLLoader( )
					.setPath( 'models/obj/' )
					.load( 'Site9-NewBldg.mtl', function ( materials ) {

						materials.preload();


						new OBJLoader( )
							.setMaterials( materials )
							.setPath( 'models/obj/' )
							.load( 'Site9-NewBldg.obj', function ( obj ) {
								// console.log(obj);

								obj.traverse( function ( child ) {

		 						 if ( child.isMesh ) child.material.clippingPlanes= [ localPlane ];
								 if ( child.isMesh ) child.material.clipShadows= true;

		 					 } );


								var object = obj.children[ 0 ].clone()

								// console.log(object);

								object.traverse( function ( child ) {
									if ( child.isMesh ) {
										// console.log(child.material.length);
										for(var i = 0; i < child.material.length; i++){
											child.material[i].clippingPlanes= [ localPlane ];
											child.material[i].clipShadows= true;
										}
									// if(child.name=='Torus'){
									// 	alert("torus");
									// 	console.log(child)
									// //	child.material.color.setHex(0xffff00);
									// }
									}
								} );


								// object.rotation.x = -3.1415926787/2;
								object.layers.set( 2 );
								object.rotation.x = -3.1415926787/2;
								object.castShadow = true;
								object.receiveShadow = true;
								scene.add( object );

							}, onProgress, onError );

					} );

					} );

					for(let i = 0; i < 71; i++){
						b[i] = new THREE.Mesh(
							new THREE.BoxGeometry(1.5,11,1.5),
							new THREE.MeshBasicMaterial({color: "#AAAAAA"})
						);

						b[i].position.y = -100;

						scene.add(b[i]);
					}




				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.VSMShadowMap;
				renderer.setClearColor( 0xCCCCCC, 1 );
				// renderer.outputEncoding = THREE.sRGBEncoding;

				// if ( ! renderer.extensions.get( 'WEBGL_depth_texture' ) ) {
				//
				// 	document.querySelector( '#error' ).style.display = 'block';
				// 	return;
				//
				// }

				renderer.localClippingEnabled = false;

				lightProbe = new THREE.LightProbe();
				scene.add( lightProbe );

				directionalLight = new THREE.DirectionalLight( 0xffffff, API.directionalLightIntensity );
				// directionalLight.position.set( 10, 10, 10 );
				directionalLight.position.set( -50, 100, -75 );
				directionalLight.castShadow = true;
				scene.add( directionalLight );




				//
				// controls.enableDamping = true;
				// 	controls.dampingFactor = 0.05;
				//
				controls.screenSpacePanning = true;
				//
				// controls.minDistance = 10;
				// controls.maxDistance = 2000;

				// composer = new EffectComposer( renderer );

				var width = window.innerWidth;
				var height = window.innerHeight;

				// var ssaoPass = new SSAOPass( scene, camera, width, height );
				// ssaoPass.kernelRadius = 6;
				// ssaoPass.minDistance = 0.013;
				// ssaoPass.maxDistance = 0.9;
				// ssaoPass.blur = false;
				// composer.addPass( ssaoPass );



				var layers = {

					// 'toggle red': function() {
					//
					// 	camera.layers.toggle( 0 );
					//
					// },

					'Site': function() {

						camera.layers.toggle( 1 );

					},

					'Building': function() {

						camera.layers.toggle( 2 );

					},

					// 'enable all': function() {
					//
					// 	camera.layers.enableAll();
					//
					// },
					//
					// 'disable all': function() {
					//
					// 	camera.layers.disableAll();
					//
					// }

				};

				// var counter1 = 0;

				var btn = { Camera:function(){ hasntBeenUpdated = true }};
				var btn1 = { Clipping:function(){ renderer.localClippingEnabled = !renderer.localClippingEnabled }};
				var btn2 = { People:function(){ peopleOn = !peopleOn }};



				//
				// Init gui
				var gui = new GUI();



				gui.add(btn,'Camera');
				gui.add(btn1,'Clipping');
				gui.add(btn2,'People');




				// gui.add( ssaoPass, 'output', {
				// 	'Default': SSAOPass.OUTPUT.Default,
				// 	'SSAO Only': SSAOPass.OUTPUT.SSAO,
				// 	'SSAO Only + Blur': SSAOPass.OUTPUT.Blur,
				// 	'Beauty': SSAOPass.OUTPUT.Beauty,
				// 	'Depth': SSAOPass.OUTPUT.Depth,
				// 	'Normal': SSAOPass.OUTPUT.Normal
				// } ).onChange( function ( value ) {
				//
				// 	ssaoPass.output = parseInt( value );} );
				// 	gui.add( ssaoPass, 'kernelRadius' ).min( 0 ).max( 32 );
				// 	gui.add( ssaoPass, 'minDistance' ).min( 0.001 ).max( 0.05 );
				// 	gui.add( ssaoPass, 'maxDistance' ).min( 0.01 ).max( 0.9 );


				// gui.add( layers, 'toggle red' );
				gui.add( layers, 'Site' );
				gui.add( layers, 'Building' );
				// gui.add( layers, 'enable all' );
				// gui.add( layers, 'disable all' );



			// folderLocal.add( propsLocal, 'Enabled' );
			// folderLocal.add( propsLocal, 'Plane', 0.3, 1.25 );


				// var fl = gui.addFolder( 'Intensity' );
				//
				// fl.add( API, 'lightProbeIntensity', 0, 1, 0.02 )
				// 	.name( 'light probe' )
				// 	.onChange( function () {
				//
				// 		lightProbe.intensity = API.lightProbeIntensity; render();
				//
				// 	} );
				//
				// fl.add( API, 'directionalLightIntensity', 0, 1, 0.02 )
				// 	.name( 'directional light' )
				// 	.onChange( function () {
				//
				// 		directionalLight.intensity = API.directionalLightIntensity; render();
				//
				// 	} );
				//
				// fl.add( API, 'envMapIntensity', 0, 1, 0.02 )
				// 	.name( 'envMap' )
				// 	.onChange( function () {
				//
				// 		// mesh.material.envMapIntensity = API.envMapIntensity; render();
				//
				// 	} );
				//
				// fl.open();

				// gui.add( effectController, "turbidity", 1.0, 20.0, 0.1 ).onChange( guiChanged );
				// gui.add( effectController, "rayleigh", 0.0, 4, 0.001 ).onChange( guiChanged );
				// gui.add( effectController, "mieCoefficient", 0.0, 0.1, 0.001 ).onChange( guiChanged );
				// gui.add( effectController, "mieDirectionalG", 0.0, 1, 0.001 ).onChange( guiChanged );
				// gui.add( effectController, "luminance", 0.0, 2 ).onChange( guiChanged );
				// gui.add( effectController, "inclination", 0, 1, 0.0001 ).onChange( guiChanged );
				// gui.add( effectController, "azimuth", 0, 1, 0.0001 ).onChange( guiChanged );
				// gui.add( effectController, "sun" ).onChange( guiChanged );

				guiChanged();

				function guiChanged() {

					var uniforms = sky.material.uniforms;
					uniforms[ "turbidity" ].value = effectController.turbidity;
					uniforms[ "rayleigh" ].value = effectController.rayleigh;
					uniforms[ "mieCoefficient" ].value = effectController.mieCoefficient;
					uniforms[ "mieDirectionalG" ].value = effectController.mieDirectionalG;
					uniforms[ "luminance" ].value = effectController.luminance;

					var theta = Math.PI * ( effectController.inclination - 0.5 );
					var phi = 2 * Math.PI * ( effectController.azimuth - 0.5 );

					var distance = 400000;

					sunSphere.position.x = distance * Math.cos( phi );
					sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
					sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );

					sunSphere.visible = effectController.sun;

					uniforms[ "sunPosition" ].value.copy( sunSphere.position );

					// renderer.render( scene, camera );

				}


				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			//
// 			var mcamPos = new THREE.Vector3(0, 0, 0); // Holds current camera position
// var targetPos = new THREE.Vector3(10, 10, -10); // Target position
// var origin = new THREE.Vector3(0, 0, 0); // Optional origin
// var targetPos = 50;



// console.log(xPaths);
			function animate() {

				requestAnimationFrame( animate );
				// console.log("x: " + camera.position.x + ", y: " + (camera.position.y) + " z: " + (camera.position.z));

			    // Interpolate camPos toward targetPos
			    // mcamPos.lerp(targetPos, 0.05);

					if(hasntBeenUpdated){
						counter1++;


						if(counter1 % 3 == 2){
							camera.position.x =27;
							camera.position.y =21;
							camera.position.z =-204;

							camera.lookAt( new THREE.Vector3(0,0,0) );
						}else if(counter1 % 3 == 1){
							camera.position.x = 157;
							camera.position.y = -46.5;
							camera.position.z = 280;

							camera.lookAt( new THREE.Vector3(0,0,0));
						}else{
							camera.position.x = -1660;
							camera.position.y = 1080;
							camera.position.z = 1520;

							camera.lookAt( new THREE.Vector3(0,0,0));
						}

						hasntBeenUpdated = false;
					}

					boxyPosIndex++;
					if(peopleOn){

					for(let j = 0; j < zPaths.length; j++){
						// console.log("j = " + j)
						// for (let i = 0; i < zPaths[j].length; i++ ){
							// console.log("i = " + i)
							// if(boxyPosIndex >= zArray[j].length){
							// 	boxyPosIndex = 0;
							// }
							let currentIndex = boxyPosIndex % zPaths[j].length;
							// console.log(zPaths[j].length);
							b[j].position.x = xPaths[j][currentIndex];
							b[j].position.y = yPaths[j][currentIndex];
							b[j].position.z = zPaths[j][currentIndex];
						// }
					}
				}else{
					for(let j = 0; j < zPaths.length; j++){
						// console.log("j = " + j)
						// for (let i = 0; i < zPaths[j].length; i++ ){
							// console.log("i = " + i)
							// if(boxyPosIndex >= zArray[j].length){
							// 	boxyPosIndex = 0;
							// }
							let currentIndex = boxyPosIndex % zPaths[j].length;
							// console.log(zPaths[j].length);
							b[j].position.x = 0;
							b[j].position.y = -100;
							b[j].position.z = 0;
						// }
					}
				}





						// console.log(xArray[boxyPosIndex]);

					// }








			    // Apply new camPos to your camera
			    // camera.position.x.lerp(targetPos, 0.05);

			    // (Optional) have camera look at the origin after it's been moved
			    // camera.lookAt(origin);


				renderer.render( scene, camera );


			}

			// render();

			function render() {
				//
				// theta += 0.1;
				//
				// camera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				// camera.position.y = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				// camera.position.z = radius * Math.cos( THREE.MathUtils.degToRad( theta ) );
				// camera.lookAt( scene.position );


				renderer.render( scene, camera );

			}

			function onProgress( xhr ) {

				if ( xhr.lengthComputable ) {

					var percentComplete = xhr.loaded / xhr.total * 100;
					// console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );

				}

			}

			function onError() {}

		</script>

</body>

</html>
