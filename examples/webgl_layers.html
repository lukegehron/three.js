<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - layers</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #f0f0f0;
			color: #444;
		}

		a {
			color: #08f;
		}
	</style>
</head>

<body>

	<div id="info">
		<!-- <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl layers -->
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';

			import { OBJLoader } from './jsm/loaders/OBJLoader.js';
			import { MTLLoader } from './jsm/loaders/MTLLoader.js';

			import { MapControls } from './jsm/controls/OrbitControls.js';

			import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
			import { SSAOPass } from './jsm/postprocessing/SSAOPass.js';

			import { Sky } from './jsm/objects/Sky.js';

			import { LightProbeGenerator } from './jsm/lights/LightProbeGenerator.js';
			import { FBXLoader } from './jsm/loaders/FBXLoader.js';

			var hasntBeenUpdated = true;

			var b = []; //box
			var spline;
			var boxPos;
			var boxyPosIndex = 0;

			var xPaths = [];
			var yPaths = [];
			var zPaths = [];


			var xArray = [];
			var yArray = [];
			var zArray = [];

			var peopleOn = false;


			var container, stats, controls;
			var camera, scene, renderer;
			var sky, sunSphere;

			var composer;

			var lightProbe, directionalLight;

			var effectController = {
				turbidity: 1,
				rayleigh: 4,
				mieCoefficient: 0.033,
				mieDirectionalG: 1,
				luminance: 0.9,
				inclination: 0.366, // elevation / inclination
				azimuth: 0.27, // Facing front,
				sun: ! true
			};
var localPlane;
var counter1 = 0;


			var API = {
				lightProbeIntensity: 1.0,
				directionalLightIntensity: 0.12,
				envMapIntensity: 0.8
			};

			var radius = 100, theta = 0;


			var params = {
				animate: true,
				planeY: {
					constant: 99,
					negated: false,
					displayHelper: false
				},
			};


			init();
			animate();

			function initSky() {

				// Add Sky
				sky = new Sky();
				sky.scale.setScalar( 450000 );
				scene.add( sky );

				// Add Sun Helper
				sunSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 20000, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				sunSphere.position.y = - 700000;
				sunSphere.visible = false;
				scene.add( sunSphere );

			}

			function init() {
				renderer = new THREE.WebGLRenderer({antialias: true});

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 5000 );

				controls = new MapControls(camera, renderer.domElement);
				controls.mouseButtons = {
				LEFT: THREE.MOUSE.PAN,
				MIDDLE: THREE.MOUSE.PAN,
				RIGHT: THREE.MOUSE.ROTATE
				}

				camera.position.x = -1660;
				camera.position.y = 1080;
				camera.position.z = 1520;


				camera.layers.enable( 0 ); // enabled by default
				camera.layers.enable( 1 );
				camera.layers.enable( 2 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );


				var	spotLight = new THREE.SpotLight( 0x888888 );
				spotLight.name = 'Spot Light';
				spotLight.angle = Math.PI / 5;
				spotLight.penumbra = 0.3;
				spotLight.position.set( 80, 200, 50 );
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 80;
				spotLight.shadow.camera.far = 2000;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.bias = -0.002;
				spotLight.shadow.radius = 12;


				var dirLight = new THREE.DirectionalLight( 0xFFFFFF, 0.13 );
				dirLight.name = 'Dir. Light';
				dirLight.position.set( 500, 1200, -750 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 5000;
				dirLight.shadow.camera.right = 1370;
				dirLight.shadow.camera.left = - 1370;
				dirLight.shadow.camera.top	= 1370;
				dirLight.shadow.camera.bottom = - 1370;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;
				dirLight.shadow.radius = 12;
				dirLight.shadow.bias = -0.002;
				scene.add( dirLight );

				var dirGroup = new THREE.Group();
				dirGroup.add( dirLight );
				scene.add( dirGroup );

				scene.add( camera );

				scene.add( new THREE.AmbientLight( 0xffffff, 0.7 ) );
				var dirLight = new THREE.DirectionalLight( 0xffffff, 0.2 );
				dirLight.position.set( -50, 100, -75 );

				scene.add( dirLight );

				initSky();

				var layer;

				var genCubeUrls = function ( prefix, postfix ) {

					return [
						prefix + 'px' + postfix, prefix + 'nx' + postfix,
						prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix
					];

				};

				// var urls = genCubeUrls( 'textures/cube/MilkyWay/dark-s_', '.jpg' );
				var urls = genCubeUrls( 'textures/cube/skyboxsun25deg/', '.jpg' );

				new THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {

					cubeTexture.encoding = THREE.sRGBEncoding;

					lightProbe.copy( LightProbeGenerator.fromCubeTexture( cubeTexture ) );

					scene.envionment = cubeTexture;

					var randomPoints = [];
					for ( var i = 0; i < 100; i ++ ) {
					    randomPoints.push(
					        new THREE.Vector3(Math.random() * 200 - 100, Math.random() * 200 - 100, Math.random() * 200 - 100)
					    );
					}
					spline = new THREE.SplineCurve3(randomPoints);

					boxPos = spline.getPoints(10000);


					localPlane = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );


					render();

					var loader = new FBXLoader();
					loader.load( 'models/fbx/lines2.fbx', function ( object ) {

						scene.add( object );

					} );

					var loader = new FBXLoader();
					loader.load( 'models/fbx/path2.fbx', function ( object ) {
						// console.log(object);
						// console.log(object.children[1].geometry.attributes.position.array[0]);
						for(let j = 0; j < object.children.length; j++){
							xArray = [];
							yArray = [];
							zArray = [];
							for (let i = 0; i < object.children[j].geometry.attributes.position.array.length; i++ ){
									if(i % 3 == 0){
										xArray.push(object.children[j].geometry.attributes.position.array[i]);
									}else if(i % 3 == 1){
										yArray.push(object.children[j].geometry.attributes.position.array[i]);
									}else{
										zArray.push(object.children[j].geometry.attributes.position.array[i]);
									}

							}
							xPaths.push(xArray);
							yPaths.push(yArray);
							zPaths.push(zArray);
						}


					} );

					var material9 = new THREE.MeshStandardMaterial( {
						color: 0xcfcdcc,
						metalness: 0.3,
						roughness: 0.7,
						envMap: cubeTexture,
						envMapIntensity: API.envMapIntensity,
						side: THREE.DoubleSide,
					} );


				var loader = new OBJLoader();
			  loader.load( 'models/obj/Site9-Terrain.obj', function ( obj )

			 {
				 obj.traverse( function ( child ) {

					 if ( child.isMesh ) child.material = material9;

				 } );
			    var layer = 1
			    var object = obj.children[ 0 ].clone();
					object.layers.set( layer );
					object.rotation.x = -3.1415926787/2;
					object.castShadow = true;
					object.receiveShadow = true;
			    scene.add( object );

			    });

				// var	material3 = new THREE.MeshStandardMaterial( {
				// 		color: 0xcccccf,
				// 		metalness: 0.3,
				// 		roughness: 0.7,
				// 		envMap: cubeTexture,
				// 		envMapIntensity: API.envMapIntensity,
				// 		clippingPlanes: [ localPlane ],
				// 		clipShadows: true
				//
				// 	} );
				// 	var loader8 = new OBJLoader();
				//
				// 	loader8.load( 'models/obj/Site11_Bldg.obj', function ( obj )
				//
				//  {
				// 	 obj.traverse( function ( child ) {
				//
				// 		 if ( child.isMesh ) child.material = material3;
				//
				// 	 } );
				//     var layer = 2
				//     var object = obj.children[ 0 ].clone();
				// 		object.layers.set( layer );
				// 		object.rotation.x = -3.1415926787/2;
				// 		object.castShadow = true;
				// 		object.receiveShadow = true;
				//     scene.add( object );
				//
				//     });

						var	material = new THREE.MeshStandardMaterial( {
								color: 0xcccccf,
								metalness: 0.3,
								roughness: 0.7,
								envMap: cubeTexture,
								envMapIntensity: API.envMapIntensity,
								// side: THREE.DoubleSide,

								// ***** Clipping setup (material): *****

							} );
							var loader9 = new OBJLoader();

							loader9.load( 'models/obj/Site9-Buildings.obj', function ( obj )

						 {
							 obj.traverse( function ( child ) {

								 if ( child.isMesh ) child.material = material;

							 } );
						    var layer = 1
						    var object = obj.children[ 0 ].clone();
								object.layers.set( layer );
								object.rotation.x = -3.1415926787/2;
								object.castShadow = true;
								object.receiveShadow = true;
						    scene.add( object );

						    });

								var urls1 = genCubeUrls( 'textures/cube/skyboxsun25deg1/', '.jpg' );

								new THREE.CubeTextureLoader().load( urls1, function ( cubeTexture1 ) {

					let material1 = new THREE.MeshPhysicalMaterial({
						color: 0xffffff,
						clearcoat: 1,
						reflectivity: 1,
						metalness:1,
						roughness: 0,
						transparency: 0.9,
						transparent:true,
						envMap: cubeTexture1,
						envMapIntensity: API.envMapIntensity,
						clippingPlanes: [ localPlane ],
						clipShadows: true
					})

					var loader = new OBJLoader();
				  loader.load( 'models/obj/Site11_Glass.obj', function ( obj )

				 {
					 obj.traverse( function ( child ) {

						 if ( child.isMesh ) child.material = material1;

					 } );
				    var layer = 2
				    var object = obj.children[ 0 ].clone();
						object.layers.set( layer );
						object.rotation.x = -3.1415926787/2;
						object.castShadow = true;
						object.receiveShadow = true;
				    scene.add( object );

				    });
					});

				new MTLLoader( )
					.setPath( 'models/obj/' )
					.load( 'Site11_Bldg8.mtl', function ( materials ) {

						materials.preload();


						new OBJLoader( )
							.setMaterials( materials )
							.setPath( 'models/obj/' )
							.load( 'Site11_Bldg8.obj', function ( obj ) {
								// console.log(obj);

								obj.traverse( function ( child ) {

		 						 if ( child.isMesh ) child.material.clippingPlanes= [ localPlane ];
								 if ( child.isMesh ) child.material.clipShadows= true;

		 					 } );


								var object = obj.children[ 0 ].clone()

								// console.log(object);

								object.traverse( function ( child ) {
									if ( child.isMesh ) {
										// console.log(child.material.length);
										for(var i = 0; i < child.material.length; i++){
											child.material[i].clippingPlanes= [ localPlane ];
											child.material[i].clipShadows= true;
										}
									}
								} );


								object.layers.set( 2 );
								object.rotation.x = -3.1415926787/2;
								object.castShadow = true;
								object.receiveShadow = true;
								scene.add( object );

							}, onProgress, onError );

					} );

					} );

					for(let i = 0; i < 71; i++){
						b[i] = new THREE.Mesh(
							new THREE.BoxGeometry(1.2,6,1.2),
							new THREE.MeshPhysicalMaterial({
								color: "#666666",
								transparency: 0.7,
								transparent:true
							})
							// new THREE.MeshBasicMaterial({color: "#AAAAAA"})
						);

						b[i].position.y = -100;

						scene.add(b[i]);
					}


				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.VSMShadowMap;
				renderer.setClearColor( 0xCCCCCC, 1 );


				renderer.localClippingEnabled = false;

				lightProbe = new THREE.LightProbe();
				scene.add( lightProbe );

				directionalLight = new THREE.DirectionalLight( 0xffffff, API.directionalLightIntensity );
				// directionalLight.position.set( 10, 10, 10 );
				directionalLight.position.set( -50, 100, -75 );
				directionalLight.castShadow = true;
				scene.add( directionalLight );

				controls.screenSpacePanning = true;

				var width = window.innerWidth;
				var height = window.innerHeight;


				var layers = {

					'Site': function() {

						camera.layers.toggle( 1 );

					},

					'Building': function() {

						camera.layers.toggle( 2 );

					},

				};

				// var counter1 = 0;

				var btn = { Camera:function(){ hasntBeenUpdated = true }};
				var btn1 = { Clipping:function(){ renderer.localClippingEnabled = !renderer.localClippingEnabled }};
				var btn2 = { People:function(){ peopleOn = !peopleOn }};



				//
				// Init gui
				var gui = new GUI();



				gui.add(btn,'Camera');
				gui.add(btn1,'Clipping');
				gui.add(btn2,'People');

				gui.add( layers, 'Site' );
				gui.add( layers, 'Building' );


				guiChanged();

				function guiChanged() {

					var uniforms = sky.material.uniforms;
					uniforms[ "turbidity" ].value = effectController.turbidity;
					uniforms[ "rayleigh" ].value = effectController.rayleigh;
					uniforms[ "mieCoefficient" ].value = effectController.mieCoefficient;
					uniforms[ "mieDirectionalG" ].value = effectController.mieDirectionalG;
					uniforms[ "luminance" ].value = effectController.luminance;

					var theta = Math.PI * ( effectController.inclination - 0.5 );
					var phi = 2 * Math.PI * ( effectController.azimuth - 0.5 );

					var distance = 400000;

					sunSphere.position.x = distance * Math.cos( phi );
					sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
					sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );

					sunSphere.visible = effectController.sun;

					uniforms[ "sunPosition" ].value.copy( sunSphere.position );
				}

				window.addEventListener( 'resize', onWindowResize, false );

			}


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );


					if(hasntBeenUpdated){
						counter1++;


						if(counter1 % 3 == 2){
							camera.position.x =27;
							camera.position.y =21;
							camera.position.z =-204;

							camera.lookAt( new THREE.Vector3(0,0,0) );
						}else if(counter1 % 3 == 1){
							camera.position.x = 157;
							camera.position.y = -46.5;
							camera.position.z = 280;

							camera.lookAt( new THREE.Vector3(0,0,0));
						}else{
							camera.position.x = -1660;
							camera.position.y = 1080;
							camera.position.z = 1520;

							camera.lookAt( new THREE.Vector3(0,0,0));
						}

						hasntBeenUpdated = false;
					}

					let multiplier = 5;

					boxyPosIndex++;
					if(peopleOn){

					for(let j = 0; j < zPaths.length; j++){

							let currentIndex = boxyPosIndex % ((zPaths[j].length*multiplier)-1);
							// console.log(zPaths[j].length);
							b[j].position.x = xPaths[j][parseInt(currentIndex/multiplier)];
							b[j].position.y = yPaths[j][parseInt(currentIndex/multiplier)] + 3;
							b[j].position.z = zPaths[j][parseInt(currentIndex/multiplier)];
						// }
					}
				}else{
					for(let j = 0; j < zPaths.length; j++){

							let currentIndex = boxyPosIndex % zPaths[j].length;

							b[j].position.x = 0;
							b[j].position.y = -100;
							b[j].position.z = 0;
						// }
					}
				}


				renderer.render( scene, camera );


			}

			// render();

			function render() {

				renderer.render( scene, camera );

			}

			function onProgress( xhr ) {

				if ( xhr.lengthComputable ) {

					var percentComplete = xhr.loaded / xhr.total * 100;
					// console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );

				}

			}

			function onError() {}

		</script>

</body>

</html>
