<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - Rhino 3DM loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
						background: #fff;
					}
					</style>
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Rhino 3DM loader
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { Rhino3dmLoader } from './jsm/loaders/3DMLoader.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';

			import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from './jsm/postprocessing/RenderPass.js';
			import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
			import { OutlinePass } from './jsm/postprocessing/OutlinePass.js';
			import { FXAAShader } from './jsm/shaders/FXAAShader.js';

			// import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
			// import { RenderPass } from './jsm/postprocessing/RenderPass.js';
			// import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
			import { CopyShader } from './jsm/shaders/CopyShader.js';
			// import { FXAAShader } from './jsm/shaders/FXAAShader.js';

			import { Line2 } from './jsm/lines/Line2.js';
			import { LineMaterial } from './jsm/lines/LineMaterial.js';
			import { LineGeometry } from './jsm/lines/LineGeometry.js';
			import { GeometryUtils } from './jsm/utils/GeometryUtils.js';



			

			let container, controls;
			let camera, scene, renderer;
			// let gui;
			let selectedObjects = []

			let goTime = false;

			let line, camera2;
			let line1;
			let matLine, matLineBasic, matLineDashed;

			let composer, effectFXAA, outlinePass;

			let mouseX = 0
			let mouseY = 0

			
			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			

			const params = {
				edgeStrength: 3.4, //8.9
				edgeGlow: 0.0,
				edgeThickness: 1, //2.1
				pulsePeriod: 0,
				rotate: false,
				usePatternTexture: false
			};
// Init gui

const gui = new GUI( { width: 300 } );

gui.add( params, 'edgeStrength', 0.01, 10 ).onChange( function ( value ) {

	outlinePass.edgeStrength = Number( value );

} );

gui.add( params, 'edgeGlow', 0.0, 1 ).onChange( function ( value ) {

	outlinePass.edgeGlow = Number( value );

} );

gui.add( params, 'edgeThickness', 1, 4 ).onChange( function ( value ) {

	outlinePass.edgeThickness = Number( value );

} );

gui.add( params, 'pulsePeriod', 0.0, 5 ).onChange( function ( value ) {

	outlinePass.pulsePeriod = Number( value );

} );

gui.add( params, 'rotate' );

gui.add( params, 'usePatternTexture' ).onChange( function ( value ) {

	outlinePass.usePatternTexture = value;

} );

function Configuration() {

	this.visibleEdgeColor = '#666666'; //'#000000'
	this.hiddenEdgeColor = '#190a05';

}

const conf = new Configuration();

gui.addColor( conf, 'visibleEdgeColor' ).onChange( function ( value ) {

	outlinePass.visibleEdgeColor.set( value );

} );

gui.addColor( conf, 'hiddenEdgeColor' ).onChange( function ( value ) {

	outlinePass.hiddenEdgeColor.set( value );

} );

let rhinoObject;

// let matLine;

			init();
			animate();

			function init() {

				THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 0, 1 );
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 12, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 290, -290, 290 );
				// camera.lookAt(100,140,0)

				scene = new THREE.Scene();
				
				scene.background = new THREE.Color( 0xffffff);

				const ambient = new THREE.AmbientLight( 0xffffff,1.25 );
				scene.add( ambient );

				const directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 0, 0, 2 );
				directionalLight.castShadow = true;
				directionalLight.intensity = 2;
				scene.add( directionalLight );

				

				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer = new THREE.WebGLRenderer( { antialias: true } ); //, alpha: true
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				container.appendChild( renderer.domElement );
				// renderer.shadowMap.enabled = true;

				// controls = new OrbitControls( camera, container );

				composer = new EffectComposer( renderer );

				const renderPass = new RenderPass( scene, camera );
				composer.addPass( renderPass );

				outlinePass = new OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
				outlinePass.overlayMaterial.blending = THREE.SubtractiveBlending
				// outlinePass.overlayMaterial.blending = THREE.CustomBlending
				outlinePass.edgeStrength = 3.4 //8.9
				outlinePass.edgeThickness = 1.0 //2.2
				composer.addPass( outlinePass );

				const textureLoader = new THREE.TextureLoader();
				textureLoader.load( 'textures/tri_pattern.jpg', function ( texture ) {

					outlinePass.patternTexture = texture;
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;

				} );

// 				var fxaaPass = new THREE.ShaderPass( THREE.FXAAShader );

// var pixelRatio = renderer.getPixelRatio();
// var uniforms = fxaaPass.material.uniforms;

// uniforms[ 'resolution' ].value.x = 1 / ( window.innerWidth * pixelRatio );
// uniforms[ 'resolution' ].value.y = 1 / ( window.innerHeight * pixelRatio );

				// effectFXAA = new ShaderPass( FXAAShader );
				// effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
				// composer.addPass( effectFXAA );

				let fxaaPass = new ShaderPass( FXAAShader );
				// const renderPass = new RenderPass( scene, camera );

				const pixelRatio = renderer.getPixelRatio();

				fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( container.offsetWidth * pixelRatio );
				fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( container.offsetHeight * pixelRatio );

				let composer1 = new EffectComposer( renderer );
				composer1.addPass( renderPass );
				composer1.addPass( fxaaPass );

				// outlinePass.selectedObjects = selectedObjects;

				const loader = new Rhino3dmLoader();
				loader.setLibraryPath( 'jsm/libs/rhino3dm/' );

				loader.load( 'models/3dm/Export13.3dm', function ( object ) { //23 //13

					// outlinePass.selectedObjects = object
					console.log(object.children[0])
					for(let i = 0; i < object.children.length; i++){
						if(object.children[i].type == "Object3D"){
							// console.log(object.children[i])
							// console.log(object.children[i].children.length)
							for(let j = 0; j < object.children[i].children.length; j++)
							{
								// console.log(j)
								selectedObjects.push(object.children[i].children[j])
							}
						}else if(object.children[i].type == "Line"){
							// console.log(object.children[i].position)
							// matLine = new LineMaterial( {

							// 	color: 0xff0000,
							// 	linewidth: 5, // in pixels
							// 	vertexColors: true,
							// 	//resolution:  // to be set by renderer, eventually
							// 	dashed: false

							// 	} );

								object.children[i].material.color = new THREE.Color( 0x666666 )
								object.children[i].position.x = 0.3
								object.children[i].position.y = -0.3
								object.children[i].position.z = 0.3
								// object.children[i].material.vertexColors = true

						}
						
						// object.children[i].material.color = '0xff0000'
					}

					rhinoObject = object

					outlinePass.selectedObjects = selectedObjects;

					scene.add( object );
					// scene.add(selectedObjects)
					initGUI( object.userData.layers );

					goTime = true;

				} );

				// scene.add(selectedObjects)

				// console.log(selectedObjects)


				window.addEventListener( 'resize', resize, false );
				
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			}

			function resize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			let currentState = 0;

			function animate() {

				// 290, -290, 250

			// camera.position.x += ( -mouseX - camera.position.x ) * .01;
			// camera.position.z += (  mouseY - camera.position.z ) * .01;

			// if(goTime){

				
			camera.position.x += ( 290 + (-mouseX*0.05) - camera.position.x ) * .1;
			camera.position.y += ( -290 + (-mouseX*0.05) - camera.position.y ) * .1;
			camera.position.z += ( 290 + (mouseY*0.1) - camera.position.z ) * .1;

			// camera.p

				// camera.position.set(290 + (-mouseX*0.05), -290  + (-mouseX*0.05), 250 + (mouseY*0.05))
			// }

			// camera.postion.z = 250 + (mouseY*0.05)
			// console.log(camera.position.x)

			// console.log(camera.position.x, mouseX + " || " + camera.position.z, mouseY,)

			camera.lookAt( scene.position );


				// controls.update();
				
				if ( !params.rotate ) {
					

					composer.render(scene, camera);
				}else{
					
					if(currentState == 0){
						for(let i = 0; i < rhinoObject.children.length; i++){
					rhinoObject.children[i].position.x = 0
					rhinoObject.children[i].position.y = 0
					rhinoObject.children[i].position.z = 0
						}
						currentState++
					}
					renderer.render( scene, camera );
				}

				
				
				// renderer.render( scene, camera );

				requestAnimationFrame( animate );

			}

			function initGUI( layers ) {

				// gui = new GUI( { width: 300 } );
				const layersControl = gui.addFolder( 'layers' );
				layersControl.open();

				for ( let i = 0; i < layers.length; i ++ ) {

					const layer = layers[ i ];
					layersControl.add( layer, 'visible' ).name( layer.name ).onChange( function ( val ) {

						const name = this.object.name;

						scene.traverse( function ( child ) {

							if ( child.userData.hasOwnProperty( 'attributes' ) ) {

								if ( 'layerIndex' in child.userData.attributes ) {

									const layerName = layers[ child.userData.attributes.layerIndex ].name;

									if ( layerName === name ) {

										child.visible = val;
										layer.visible = val;

									}

								}

							}

						} );

					} );

				}

			}

			function onDocumentMouseMove( event ) {

			mouseX = ( event.clientX - windowHalfX ) / 2;
			mouseY = ( event.clientY - windowHalfY ) / 2;

			// console.log(mouseX, mouseY)

			}

			//

			// function animate() {

			// requestAnimationFrame( animate );
			// render();

			// }

			// function render() {

			// camera.position.x += ( mouseX - camera.position.x ) * .05;
			// camera.position.y += ( - mouseY - camera.position.y ) * .05;

			// camera.lookAt( scene.position );

			// renderer.render( scene, camera );

			// }
		</script>

	</body>
</html>
